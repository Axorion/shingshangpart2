@startuml

class Tuple<F,S> {
    -F firstElement;
    -S secondElement;

    +F getFirstElement()

    +S getSecondElement()

    +void setFirstElement(F firstElement)

    +void setSecondElement(S secondElement)
}

class MovementsInformation{
    -HashMap<Square, Tuple<Square, LinkedList<Square>>> movementsHashMap

    +HashMap<Square, Tuple<Square, LinkedList<Square>>> getMovementsHashMap()

    +Tuple<Square, LinkedList<Square>> getMovementsInformation(Square destination)

    +void setMovementsInformation(Square destination, Square squareOfCapturedPawn, LinkedList<Square> historic)

    +void setAllMovementInformation(MovementsInformation movementsInformation)

    +LinkedList<Square> getHistoric(Square destination)

    +Square getCapturedPawn(Square destination)
}

note top of MovementsInformation: Classe modélisant un type de donnée renvoyé par les méthodes de mouvements du "Board".\nOn associe à une case de destination un tuple.\nCe tuple correspond à la case d'un pion capturé lors du déplacement, et à une liste des cases parcourus pour arriver à la case destination.

class Player{
    -int id
    -int score
    +void resetPoint()
    +boolean movePawn(Square fromSquare, Square toSquare)
    +void loseAPoint()
}

class Board{
    -final int COLS = 10;
    -final int ROWS = 10;
    -{static} final int NO_TEAM_ID = -1
    +{static} final int FIRST_TEAM_ID = 0
    +{static} final int SECOND_TEAM_ID = 1
    +{static} boolean isValidTeamId(int teamId)
    -Square getSquare(int x, int y)
    -void setPawnOnSquare(Square square, IPawn pawn)
    -void setFirstPlayerPawns(int ownerId)
    -void setSecondPlayerPawns(int ownerId)
    +void reset(int[] players)
    -MovementsInformation getAvailableGoToSquares(IPawn pawn, Square currentSquare)
    -MovementsInformation getAvailableJumpToSquares(IPawn pawn, Square currentSquare, Square lastSquare, MovementsInformation availableJumpToSquares)
    +MovementsInformation getAvailableMovements(int[] currentSquareCoords)
    +boolean movePawn(int[] fromSquareCoords, int[] toSquareCoords)
    -void capturePawn(Square square)
    +int winner()
    -boolean validCoords(int x , int y)
    +String toString()
}

class Square{
    -IPawn pawn;
    -int x;
    -int y;
    +boolean hasPawn()
    +IPawn getPawn()
    +void setPawn(IPawn pawn)
    +boolean hasPawn()
    +int getX()
    +int getY()
    +String toString()
}

interface IPawn{
    +int getTeamId()
    +int getHeight()
    +int getMovementRange()
    +boolean canJump(Square fromSquare, Square betweenSquare, Square toSquare)
    +boolean canGo(Square fromSquare, Square toSquare)
}

abstract class Pawn implements IPawn{
    -int ownerId
    -int height
    -int range
    +int getTeamId()
    +int getHeight()
    +int getMovementRange()
    +boolean canJump(Square fromSquare, Square betweenSquare, Square toSquare)
    +boolean canGo(Square fromSquare, Square toSquare)
    +String toString()
}

class Dragon{
    -{static}final int MAX_MOVE_RANGE = 0
    -{static}final int height = 3
}

class Lion{
    -{static}final int MAX_MOVE_RANGE = 1
    -{static}final int height = 2
}

class Monkey{
    -{static}final int MAX_MOVE_RANGE = 2
    -{static}final int height = 1
}

class Wall{
    -{static}final int MAX_MOVE_RANGE = 0
    -{static}final int height = 4
}

Player "2" -- "1" Board
Board "1" --> "84" Square
Square "0..1" -- "0..1" IPawn
Pawn <|-- Dragon
Pawn <|-- Lion
Pawn <|-- Monkey
Pawn <|-- Wall

@enduml